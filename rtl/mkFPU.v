//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Aug 31 17:22:46 BST 2017
//
//
// Ports:
// Name                         I/O  size props
// reqIn_didPut                   O     1
// RDY_respOut_get                O     1 const
// respOut_valid                  O     1 reg
// respOut_value                  O    42 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// reqIn_tryPut_val               I    77
// EN_reqIn_tryPut                I     1
// EN_respOut_get                 I     1
//
// Combinational paths from inputs to outputs:
//   (reqIn_tryPut_val, EN_reqIn_tryPut) -> reqIn_didPut
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFPU(CLK,
	     RST_N,

	     reqIn_tryPut_val,
	     EN_reqIn_tryPut,

	     reqIn_didPut,

	     EN_respOut_get,
	     RDY_respOut_get,

	     respOut_valid,

	     respOut_value);
  input  CLK;
  input  RST_N;

  // action method reqIn_tryPut
  input  [76 : 0] reqIn_tryPut_val;
  input  EN_reqIn_tryPut;

  // value method reqIn_didPut
  output reqIn_didPut;

  // action method respOut_get
  input  EN_respOut_get;
  output RDY_respOut_get;

  // value method respOut_valid
  output respOut_valid;

  // value method respOut_value
  output [41 : 0] respOut_value;

  // signals for module outputs
  wire [41 : 0] respOut_value;
  wire RDY_respOut_get, reqIn_didPut, respOut_valid;

  // inlined wires
  wire [41 : 0] respBuffer_q_q_doEnq$wget;
  wire reqPort_doGetWire$whas, respBuffer_q_q_doDeq$whas;

  // register inflightCount_count
  reg [5 : 0] inflightCount_count;
  wire [5 : 0] inflightCount_count$D_IN;
  wire inflightCount_count$EN;

  // register inflightCount_full
  reg inflightCount_full;
  wire inflightCount_full$D_IN, inflightCount_full$EN;

  // register intMult_reg1
  reg [65 : 0] intMult_reg1;
  wire [65 : 0] intMult_reg1$D_IN;
  wire intMult_reg1$EN;

  // register intMult_reg2
  reg [65 : 0] intMult_reg2;
  wire [65 : 0] intMult_reg2$D_IN;
  wire intMult_reg2$EN;

  // register intMult_reg3
  reg [31 : 0] intMult_reg3;
  wire [31 : 0] intMult_reg3$D_IN;
  wire intMult_reg3$EN;

  // register intMult_sel1
  reg intMult_sel1;
  wire intMult_sel1$D_IN, intMult_sel1$EN;

  // register intMult_sel2
  reg intMult_sel2;
  wire intMult_sel2$D_IN, intMult_sel2$EN;

  // register respBuffer_buffer
  reg [41 : 0] respBuffer_buffer;
  wire [41 : 0] respBuffer_buffer$D_IN;
  wire respBuffer_buffer$EN;

  // register respBuffer_bufferValid
  reg respBuffer_bufferValid;
  wire respBuffer_bufferValid$D_IN, respBuffer_bufferValid$EN;

  // register respBuffer_frontReg
  reg [41 : 0] respBuffer_frontReg;
  wire [41 : 0] respBuffer_frontReg$D_IN;
  wire respBuffer_frontReg$EN;

  // register respBuffer_frontValid
  reg respBuffer_frontValid;
  wire respBuffer_frontValid$D_IN, respBuffer_frontValid$EN;

  // register respBuffer_qValid
  reg respBuffer_qValid;
  wire respBuffer_qValid$D_IN, respBuffer_qValid$EN;

  // register respBuffer_q_q_back
  reg [4 : 0] respBuffer_q_q_back;
  wire [4 : 0] respBuffer_q_q_back$D_IN;
  wire respBuffer_q_q_back$EN;

  // register respBuffer_q_q_canPeekReg
  reg respBuffer_q_q_canPeekReg;
  wire respBuffer_q_q_canPeekReg$D_IN, respBuffer_q_q_canPeekReg$EN;

  // register respBuffer_q_q_deqEnable
  reg respBuffer_q_q_deqEnable;
  wire respBuffer_q_q_deqEnable$D_IN, respBuffer_q_q_deqEnable$EN;

  // register respBuffer_q_q_empty
  reg respBuffer_q_q_empty;
  wire respBuffer_q_q_empty$D_IN, respBuffer_q_q_empty$EN;

  // register respBuffer_q_q_front
  reg [4 : 0] respBuffer_q_q_front;
  wire [4 : 0] respBuffer_q_q_front$D_IN;
  wire respBuffer_q_q_front$EN;

  // register respBuffer_q_q_full
  reg respBuffer_q_q_full;
  wire respBuffer_q_q_full$D_IN, respBuffer_q_q_full$EN;

  // register respBuffer_q_q_length
  reg [5 : 0] respBuffer_q_q_length;
  wire [5 : 0] respBuffer_q_q_length$D_IN;
  wire respBuffer_q_q_length$EN;

  // register tokens_0
  reg [9 : 0] tokens_0;
  wire [9 : 0] tokens_0$D_IN;
  wire tokens_0$EN;

  // register tokens_1
  reg [9 : 0] tokens_1;
  wire [9 : 0] tokens_1$D_IN;
  wire tokens_1$EN;

  // register tokens_10
  reg [9 : 0] tokens_10;
  wire [9 : 0] tokens_10$D_IN;
  wire tokens_10$EN;

  // register tokens_11
  reg [9 : 0] tokens_11;
  wire [9 : 0] tokens_11$D_IN;
  wire tokens_11$EN;

  // register tokens_12
  reg [9 : 0] tokens_12;
  wire [9 : 0] tokens_12$D_IN;
  wire tokens_12$EN;

  // register tokens_13
  reg [9 : 0] tokens_13;
  wire [9 : 0] tokens_13$D_IN;
  wire tokens_13$EN;

  // register tokens_14
  reg [9 : 0] tokens_14;
  wire [9 : 0] tokens_14$D_IN;
  wire tokens_14$EN;

  // register tokens_15
  reg [9 : 0] tokens_15;
  wire [9 : 0] tokens_15$D_IN;
  wire tokens_15$EN;

  // register tokens_2
  reg [9 : 0] tokens_2;
  wire [9 : 0] tokens_2$D_IN;
  wire tokens_2$EN;

  // register tokens_3
  reg [9 : 0] tokens_3;
  wire [9 : 0] tokens_3$D_IN;
  wire tokens_3$EN;

  // register tokens_4
  reg [9 : 0] tokens_4;
  wire [9 : 0] tokens_4$D_IN;
  wire tokens_4$EN;

  // register tokens_5
  reg [9 : 0] tokens_5;
  wire [9 : 0] tokens_5$D_IN;
  wire tokens_5$EN;

  // register tokens_6
  reg [9 : 0] tokens_6;
  wire [9 : 0] tokens_6$D_IN;
  wire tokens_6$EN;

  // register tokens_7
  reg [9 : 0] tokens_7;
  wire [9 : 0] tokens_7$D_IN;
  wire tokens_7$EN;

  // register tokens_8
  reg [9 : 0] tokens_8;
  wire [9 : 0] tokens_8$D_IN;
  wire tokens_8$EN;

  // register tokens_9
  reg [9 : 0] tokens_9;
  wire [9 : 0] tokens_9$D_IN;
  wire tokens_9$EN;

  // ports of submodule fpAddSub_op
  wire [31 : 0] fpAddSub_op$dataa, fpAddSub_op$datab, fpAddSub_op$result;
  wire fpAddSub_op$add_sub,
       fpAddSub_op$nan,
       fpAddSub_op$overflow,
       fpAddSub_op$underflow;

  // ports of submodule fpCompare_op
  wire [31 : 0] fpCompare_op$dataa, fpCompare_op$datab;
  wire fpCompare_op$aeb, fpCompare_op$alb, fpCompare_op$aleb;

  // ports of submodule fpDiv_op
  wire [31 : 0] fpDiv_op$dataa, fpDiv_op$datab, fpDiv_op$result;
  wire fpDiv_op$division_by_zero,
       fpDiv_op$nan,
       fpDiv_op$overflow,
       fpDiv_op$underflow;

  // ports of submodule fpFromInt_op
  wire [31 : 0] fpFromInt_op$dataa, fpFromInt_op$result;

  // ports of submodule fpMult_op
  wire [31 : 0] fpMult_op$dataa, fpMult_op$datab, fpMult_op$result;
  wire fpMult_op$nan, fpMult_op$overflow, fpMult_op$underflow;

  // ports of submodule fpToInt_op
  wire [31 : 0] fpToInt_op$dataa, fpToInt_op$result;
  wire fpToInt_op$nan, fpToInt_op$overflow, fpToInt_op$underflow;

  // ports of submodule intMult_mult
  wire [65 : 0] intMult_mult$res;
  wire [32 : 0] intMult_mult$dataa, intMult_mult$datab;

  // ports of submodule respBuffer_q_q_ram
  wire [41 : 0] respBuffer_q_q_ram$DI, respBuffer_q_q_ram$DO;
  wire [4 : 0] respBuffer_q_q_ram$RD_ADDR, respBuffer_q_q_ram$WR_ADDR;
  wire respBuffer_q_q_ram$RE, respBuffer_q_q_ram$WE;

  // remaining internal signals
  reg [31 : 0] x_out_val__h8046;
  reg IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d177,
      IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d186,
      IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d195;
  wire [9 : 0] _1_CONCAT_IF_reqPort_putWireContents_whas__9_TH_ETC___d104;
  wire [5 : 0] newCount__h3571,
	       v__h1874,
	       v__h1890,
	       v__h1940,
	       x__h3610,
	       y__h3611,
	       y__h3613;
  wire [4 : 0] incFront__h1810;
  wire IF_NOT_respBuffer_frontValid_1_2_OR_respBuffer_ETC___d58,
       NOT_respBuffer_frontValid_1_2_OR_respBuffer_do_ETC___d51,
       reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d111,
       reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d124,
       reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d133,
       reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d140,
       reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d93,
       x__h8069,
       x__h8077,
       x__h8085,
       x__h8093;

  // value method reqIn_didPut
  assign reqIn_didPut = reqPort_doGetWire$whas ;

  // action method respOut_get
  assign RDY_respOut_get = 1'd1 ;

  // value method respOut_valid
  assign respOut_valid = respBuffer_frontValid ;

  // value method respOut_value
  assign respOut_value = respBuffer_frontReg ;

  // submodule fpAddSub_op
  AlteraFPAddSub fpAddSub_op(.clock(CLK),
			     .add_sub(fpAddSub_op$add_sub),
			     .dataa(fpAddSub_op$dataa),
			     .datab(fpAddSub_op$datab),
			     .result(fpAddSub_op$result),
			     .nan(fpAddSub_op$nan),
			     .overflow(fpAddSub_op$overflow),
			     .underflow(fpAddSub_op$underflow));

  // submodule fpCompare_op
  AlteraFPCompare fpCompare_op(.clock(CLK),
			       .dataa(fpCompare_op$dataa),
			       .datab(fpCompare_op$datab),
			       .aeb(fpCompare_op$aeb),
			       .alb(fpCompare_op$alb),
			       .aleb(fpCompare_op$aleb));

  // submodule fpDiv_op
  AlteraFPDiv fpDiv_op(.clock(CLK),
		       .dataa(fpDiv_op$dataa),
		       .datab(fpDiv_op$datab),
		       .result(fpDiv_op$result),
		       .nan(fpDiv_op$nan),
		       .overflow(fpDiv_op$overflow),
		       .underflow(fpDiv_op$underflow),
		       .division_by_zero(fpDiv_op$division_by_zero));

  // submodule fpFromInt_op
  AlteraFPFromInt fpFromInt_op(.clock(CLK),
			       .dataa(fpFromInt_op$dataa),
			       .result(fpFromInt_op$result));

  // submodule fpMult_op
  AlteraFPMult fpMult_op(.clock(CLK),
			 .dataa(fpMult_op$dataa),
			 .datab(fpMult_op$datab),
			 .result(fpMult_op$result),
			 .nan(fpMult_op$nan),
			 .overflow(fpMult_op$overflow),
			 .underflow(fpMult_op$underflow));

  // submodule fpToInt_op
  AlteraFPToInt fpToInt_op(.clock(CLK),
			   .dataa(fpToInt_op$dataa),
			   .result(fpToInt_op$result),
			   .nan(fpToInt_op$nan),
			   .overflow(fpToInt_op$overflow),
			   .underflow(fpToInt_op$underflow));

  // submodule intMult_mult
  AlteraSignedMult #(.WIDTH(32'd33)) intMult_mult(.CLK(CLK),
						  .dataa(intMult_mult$dataa),
						  .datab(intMult_mult$datab),
						  .res(intMult_mult$res));

  // submodule respBuffer_q_q_ram
  AlteraBlockRam #(.ADDR_WIDTH(32'd5),
		   .DATA_WIDTH(32'd42),
		   .NUM_ELEMS(32'd32),
		   .BE_WIDTH(32'd1),
		   .RD_DURING_WR("DONT_CARE"),
		   .DO_REG("CLOCK0"),
		   .INIT_FILE("UNUSED"),
		   .DEV_FAMILY("Stratix V")) respBuffer_q_q_ram(.BE(1'b1),
								.CLK(CLK),
								.DI(respBuffer_q_q_ram$DI),
								.RD_ADDR(respBuffer_q_q_ram$RD_ADDR),
								.WR_ADDR(respBuffer_q_q_ram$WR_ADDR),
								.RE(respBuffer_q_q_ram$RE),
								.WE(respBuffer_q_q_ram$WE),
								.DO(respBuffer_q_q_ram$DO));

  // inlined wires
  assign reqPort_doGetWire$whas =
	     reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d133 &&
	     (reqIn_tryPut_val[70:68] == 3'd1 ||
	      reqIn_tryPut_val[70:68] == 3'd3) ||
	     reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d140 ;
  assign respBuffer_q_q_doEnq$wget =
	     { tokens_1[5:0],
	       x_out_val__h8046,
	       x__h8069,
	       x__h8077,
	       x__h8085,
	       x__h8093 } ;
  assign respBuffer_q_q_doDeq$whas =
	     (!respBuffer_frontValid || EN_respOut_get) &&
	     respBuffer_q_q_deqEnable ;

  // register inflightCount_count
  assign inflightCount_count$D_IN = newCount__h3571 ;
  assign inflightCount_count$EN = 1'd1 ;

  // register inflightCount_full
  assign inflightCount_full$D_IN = newCount__h3571 == 6'd32 ;
  assign inflightCount_full$EN = 1'd1 ;

  // register intMult_reg1
  assign intMult_reg1$D_IN = intMult_mult$res ;
  assign intMult_reg1$EN = 1'd1 ;

  // register intMult_reg2
  assign intMult_reg2$D_IN = intMult_reg1 ;
  assign intMult_reg2$EN = 1'd1 ;

  // register intMult_reg3
  assign intMult_reg3$D_IN =
	     intMult_sel2 ? intMult_reg2[63:32] : intMult_reg2[31:0] ;
  assign intMult_reg3$EN = 1'd1 ;

  // register intMult_sel1
  assign intMult_sel1$D_IN = reqIn_tryPut_val[0] ;
  assign intMult_sel1$EN = 1'd1 ;

  // register intMult_sel2
  assign intMult_sel2$D_IN = intMult_sel1 ;
  assign intMult_sel2$EN = 1'd1 ;

  // register respBuffer_buffer
  assign respBuffer_buffer$D_IN = respBuffer_q_q_ram$DO ;
  assign respBuffer_buffer$EN =
	     IF_NOT_respBuffer_frontValid_1_2_OR_respBuffer_ETC___d58 ;

  // register respBuffer_bufferValid
  assign respBuffer_bufferValid$D_IN =
	     respBuffer_frontValid && !EN_respOut_get || respBuffer_qValid ;
  assign respBuffer_bufferValid$EN =
	     NOT_respBuffer_frontValid_1_2_OR_respBuffer_do_ETC___d51 ;

  // register respBuffer_frontReg
  assign respBuffer_frontReg$D_IN =
	     respBuffer_bufferValid ?
	       respBuffer_buffer :
	       respBuffer_q_q_ram$DO ;
  assign respBuffer_frontReg$EN = !respBuffer_frontValid || EN_respOut_get ;

  // register respBuffer_frontValid
  assign respBuffer_frontValid$D_IN =
	     respBuffer_bufferValid || respBuffer_qValid ;
  assign respBuffer_frontValid$EN = !respBuffer_frontValid || EN_respOut_get ;

  // register respBuffer_qValid
  assign respBuffer_qValid$D_IN = respBuffer_q_q_doDeq$whas ;
  assign respBuffer_qValid$EN = 1'd1 ;

  // register respBuffer_q_q_back
  assign respBuffer_q_q_back$D_IN = respBuffer_q_q_back + 5'd1 ;
  assign respBuffer_q_q_back$EN = tokens_1[9] ;

  // register respBuffer_q_q_canPeekReg
  assign respBuffer_q_q_canPeekReg$D_IN =
	     respBuffer_q_q_deqEnable && !respBuffer_q_q_doDeq$whas ;
  assign respBuffer_q_q_canPeekReg$EN = 1'd1 ;

  // register respBuffer_q_q_deqEnable
  assign respBuffer_q_q_deqEnable$D_IN =
	     (!respBuffer_q_q_doDeq$whas || respBuffer_q_q_length != 6'd1) &&
	     !respBuffer_q_q_empty ;
  assign respBuffer_q_q_deqEnable$EN = 1'd1 ;

  // register respBuffer_q_q_empty
  assign respBuffer_q_q_empty$D_IN =
	     !tokens_1[9] || respBuffer_q_q_doDeq$whas ;
  assign respBuffer_q_q_empty$EN =
	     tokens_1[9] && !respBuffer_q_q_doDeq$whas ||
	     respBuffer_q_q_doDeq$whas && respBuffer_q_q_length == 6'd1 &&
	     !tokens_1[9] ;

  // register respBuffer_q_q_front
  assign respBuffer_q_q_front$D_IN =
	     respBuffer_q_q_doDeq$whas ?
	       incFront__h1810 :
	       respBuffer_q_q_front ;
  assign respBuffer_q_q_front$EN = 1'd1 ;

  // register respBuffer_q_q_full
  assign respBuffer_q_q_full$D_IN =
	     tokens_1[9] && respBuffer_q_q_length == 6'd31 ;
  assign respBuffer_q_q_full$EN =
	     tokens_1[9] && !respBuffer_q_q_doDeq$whas ||
	     !tokens_1[9] && respBuffer_q_q_doDeq$whas ;

  // register respBuffer_q_q_length
  assign respBuffer_q_q_length$D_IN = respBuffer_q_q_length + v__h1874 ;
  assign respBuffer_q_q_length$EN = 1'd1 ;

  // register tokens_0
  assign tokens_0$D_IN = 10'h0 ;
  assign tokens_0$EN = 1'b0 ;

  // register tokens_1
  assign tokens_1$D_IN = tokens_2 ;
  assign tokens_1$EN = 1'd1 ;

  // register tokens_10
  assign tokens_10$D_IN = tokens_11 ;
  assign tokens_10$EN = 1'd1 ;

  // register tokens_11
  assign tokens_11$D_IN =
	     (reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d124 &&
	      reqIn_tryPut_val[70:68] == 3'd2) ?
	       _1_CONCAT_IF_reqPort_putWireContents_whas__9_TH_ETC___d104 :
	       tokens_12 ;
  assign tokens_11$EN = 1'd1 ;

  // register tokens_12
  assign tokens_12$D_IN = tokens_13 ;
  assign tokens_12$EN = 1'd1 ;

  // register tokens_13
  assign tokens_13$D_IN = tokens_14 ;
  assign tokens_13$EN = 1'd1 ;

  // register tokens_14
  assign tokens_14$D_IN =
	     (reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d133 &&
	      (reqIn_tryPut_val[70:68] == 3'd1 ||
	       reqIn_tryPut_val[70:68] == 3'd3)) ?
	       _1_CONCAT_IF_reqPort_putWireContents_whas__9_TH_ETC___d104 :
	       tokens_15 ;
  assign tokens_14$EN = 1'd1 ;

  // register tokens_15
  assign tokens_15$D_IN = 10'h0 ;
  assign tokens_15$EN = 1'b0 ;

  // register tokens_2
  assign tokens_2$D_IN = tokens_3 ;
  assign tokens_2$EN = 1'd1 ;

  // register tokens_3
  assign tokens_3$D_IN =
	     (reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d93 &&
	      (reqIn_tryPut_val[70:68] == 3'd0 ||
	       reqIn_tryPut_val[70:68] == 3'd6)) ?
	       _1_CONCAT_IF_reqPort_putWireContents_whas__9_TH_ETC___d104 :
	       tokens_4 ;
  assign tokens_3$EN = 1'd1 ;

  // register tokens_4
  assign tokens_4$D_IN = tokens_5 ;
  assign tokens_4$EN = 1'd1 ;

  // register tokens_5
  assign tokens_5$D_IN = tokens_6 ;
  assign tokens_5$EN = 1'd1 ;

  // register tokens_6
  assign tokens_6$D_IN =
	     (reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d111 &&
	      (reqIn_tryPut_val[70:68] == 3'd4 ||
	       reqIn_tryPut_val[70:68] == 3'd5)) ?
	       _1_CONCAT_IF_reqPort_putWireContents_whas__9_TH_ETC___d104 :
	       tokens_7 ;
  assign tokens_6$EN = 1'd1 ;

  // register tokens_7
  assign tokens_7$D_IN = tokens_8 ;
  assign tokens_7$EN = 1'd1 ;

  // register tokens_8
  assign tokens_8$D_IN = tokens_9 ;
  assign tokens_8$EN = 1'd1 ;

  // register tokens_9
  assign tokens_9$D_IN = tokens_10 ;
  assign tokens_9$EN = 1'd1 ;

  // submodule fpAddSub_op
  assign fpAddSub_op$add_sub = reqIn_tryPut_val[1] ;
  assign fpAddSub_op$dataa = intMult_mult$dataa[31:0] ;
  assign fpAddSub_op$datab = intMult_mult$datab[31:0] ;

  // submodule fpCompare_op
  assign fpCompare_op$dataa = intMult_mult$dataa[31:0] ;
  assign fpCompare_op$datab = intMult_mult$datab[31:0] ;

  // submodule fpDiv_op
  assign fpDiv_op$dataa = intMult_mult$dataa[31:0] ;
  assign fpDiv_op$datab = intMult_mult$datab[31:0] ;

  // submodule fpFromInt_op
  assign fpFromInt_op$dataa = intMult_mult$dataa[31:0] ;

  // submodule fpMult_op
  assign fpMult_op$dataa = intMult_mult$dataa[31:0] ;
  assign fpMult_op$datab = intMult_mult$datab[31:0] ;

  // submodule fpToInt_op
  assign fpToInt_op$dataa = intMult_mult$dataa[31:0] ;

  // submodule intMult_mult
  assign intMult_mult$dataa = reqIn_tryPut_val[67:35] ;
  assign intMult_mult$datab = reqIn_tryPut_val[34:2] ;

  // submodule respBuffer_q_q_ram
  assign respBuffer_q_q_ram$DI = respBuffer_q_q_doEnq$wget ;
  assign respBuffer_q_q_ram$RD_ADDR =
	     respBuffer_q_q_doDeq$whas ?
	       incFront__h1810 :
	       respBuffer_q_q_front ;
  assign respBuffer_q_q_ram$WR_ADDR = respBuffer_q_q_back ;
  assign respBuffer_q_q_ram$RE = 1'd1 ;
  assign respBuffer_q_q_ram$WE = tokens_1[9] ;

  // remaining internal signals
  assign IF_NOT_respBuffer_frontValid_1_2_OR_respBuffer_ETC___d58 =
	     (!respBuffer_frontValid || EN_respOut_get) ?
	       respBuffer_bufferValid :
	       respBuffer_qValid ;
  assign NOT_respBuffer_frontValid_1_2_OR_respBuffer_do_ETC___d51 =
	     (!respBuffer_frontValid || EN_respOut_get) &&
	     respBuffer_bufferValid ||
	     respBuffer_frontValid && !EN_respOut_get && respBuffer_qValid ;
  assign _1_CONCAT_IF_reqPort_putWireContents_whas__9_TH_ETC___d104 =
	     { 1'd1, reqIn_tryPut_val[70:68], reqIn_tryPut_val[76:71] } ;
  assign incFront__h1810 = respBuffer_q_q_front + 5'd1 ;
  assign newCount__h3571 = x__h3610 - y__h3611 ;
  assign reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d111 =
	     EN_reqIn_tryPut && !inflightCount_full && !tokens_7[9] ;
  assign reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d124 =
	     EN_reqIn_tryPut && !inflightCount_full && !tokens_12[9] ;
  assign reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d133 =
	     EN_reqIn_tryPut && !inflightCount_full && !tokens_15[9] ;
  assign reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d140 =
	     reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d124 &&
	     reqIn_tryPut_val[70:68] == 3'd2 ||
	     reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d111 &&
	     (reqIn_tryPut_val[70:68] == 3'd4 ||
	      reqIn_tryPut_val[70:68] == 3'd5) ||
	     reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d93 &&
	     (reqIn_tryPut_val[70:68] == 3'd0 ||
	      reqIn_tryPut_val[70:68] == 3'd6) ;
  assign reqPort_putWireValid_whas__4_AND_reqPort_putWi_ETC___d93 =
	     EN_reqIn_tryPut && !inflightCount_full && !tokens_4[9] ;
  assign v__h1874 = tokens_1[9] ? v__h1940 : v__h1890 ;
  assign v__h1890 = respBuffer_q_q_doDeq$whas ? 6'd63 : 6'd0 ;
  assign v__h1940 = respBuffer_q_q_doDeq$whas ? 6'd0 : 6'd1 ;
  assign x__h3610 = inflightCount_count + y__h3613 ;
  assign x__h8069 =
	     tokens_1[8:6] != 3'd0 &&
	     IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d177 ;
  assign x__h8077 =
	     tokens_1[8:6] != 3'd0 &&
	     IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d186 ;
  assign x__h8085 =
	     tokens_1[8:6] != 3'd0 &&
	     IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d195 ;
  assign x__h8093 = tokens_1[8:6] == 3'd3 && fpDiv_op$division_by_zero ;
  assign y__h3611 = EN_respOut_get ? 6'd1 : 6'd0 ;
  assign y__h3613 = reqPort_doGetWire$whas ? 6'd1 : 6'd0 ;
  always@(tokens_1 or
	  fpCompare_op$aleb or
	  fpCompare_op$alb or
	  fpCompare_op$aeb or
	  intMult_reg3 or
	  fpAddSub_op$result or
	  fpMult_op$result or
	  fpDiv_op$result or fpToInt_op$result or fpFromInt_op$result)
  begin
    case (tokens_1[8:6])
      3'd0: x_out_val__h8046 = intMult_reg3;
      3'd1: x_out_val__h8046 = fpAddSub_op$result;
      3'd2: x_out_val__h8046 = fpMult_op$result;
      3'd3: x_out_val__h8046 = fpDiv_op$result;
      3'd4: x_out_val__h8046 = fpToInt_op$result;
      3'd5: x_out_val__h8046 = fpFromInt_op$result;
      default: x_out_val__h8046 =
		   { 29'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ,
		     fpCompare_op$aleb,
		     fpCompare_op$alb,
		     fpCompare_op$aeb };
    endcase
  end
  always@(tokens_1 or
	  fpToInt_op$overflow or
	  fpAddSub_op$overflow or fpMult_op$overflow or fpDiv_op$overflow)
  begin
    case (tokens_1[8:6])
      3'd1:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d186 =
	      fpAddSub_op$overflow;
      3'd2:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d186 =
	      fpMult_op$overflow;
      3'd3:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d186 =
	      fpDiv_op$overflow;
      default: IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d186 =
		   tokens_1[8:6] == 3'd4 && fpToInt_op$overflow;
    endcase
  end
  always@(tokens_1 or
	  fpToInt_op$nan or fpAddSub_op$nan or fpMult_op$nan or fpDiv_op$nan)
  begin
    case (tokens_1[8:6])
      3'd1:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d177 =
	      fpAddSub_op$nan;
      3'd2:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d177 =
	      fpMult_op$nan;
      3'd3:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d177 =
	      fpDiv_op$nan;
      default: IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d177 =
		   tokens_1[8:6] == 3'd4 && fpToInt_op$nan;
    endcase
  end
  always@(tokens_1 or
	  fpToInt_op$underflow or
	  fpAddSub_op$underflow or fpMult_op$underflow or fpDiv_op$underflow)
  begin
    case (tokens_1[8:6])
      3'd1:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d195 =
	      fpAddSub_op$underflow;
      3'd2:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d195 =
	      fpMult_op$underflow;
      3'd3:
	  IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d195 =
	      fpDiv_op$underflow;
      default: IF_tokens_1_read__42_BITS_8_TO_6_45_EQ_1_48_TH_ETC___d195 =
		   tokens_1[8:6] == 3'd4 && fpToInt_op$underflow;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        inflightCount_count <= `BSV_ASSIGNMENT_DELAY 6'd0;
	inflightCount_full <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_bufferValid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_frontValid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_qValid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_q_q_back <= `BSV_ASSIGNMENT_DELAY 5'd0;
	respBuffer_q_q_canPeekReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_q_q_deqEnable <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_q_q_empty <= `BSV_ASSIGNMENT_DELAY 1'd1;
	respBuffer_q_q_front <= `BSV_ASSIGNMENT_DELAY 5'd0;
	respBuffer_q_q_full <= `BSV_ASSIGNMENT_DELAY 1'd0;
	respBuffer_q_q_length <= `BSV_ASSIGNMENT_DELAY 6'd0;
	tokens_0 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_1 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_10 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_11 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_12 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_13 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_14 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_15 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_2 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_3 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_4 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_5 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_6 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_7 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_8 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
	tokens_9 <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0, 9'bxxxxxxxxx /* unspecified value */  };
      end
    else
      begin
        if (inflightCount_count$EN)
	  inflightCount_count <= `BSV_ASSIGNMENT_DELAY
	      inflightCount_count$D_IN;
	if (inflightCount_full$EN)
	  inflightCount_full <= `BSV_ASSIGNMENT_DELAY inflightCount_full$D_IN;
	if (respBuffer_bufferValid$EN)
	  respBuffer_bufferValid <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_bufferValid$D_IN;
	if (respBuffer_frontValid$EN)
	  respBuffer_frontValid <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_frontValid$D_IN;
	if (respBuffer_qValid$EN)
	  respBuffer_qValid <= `BSV_ASSIGNMENT_DELAY respBuffer_qValid$D_IN;
	if (respBuffer_q_q_back$EN)
	  respBuffer_q_q_back <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_back$D_IN;
	if (respBuffer_q_q_canPeekReg$EN)
	  respBuffer_q_q_canPeekReg <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_canPeekReg$D_IN;
	if (respBuffer_q_q_deqEnable$EN)
	  respBuffer_q_q_deqEnable <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_deqEnable$D_IN;
	if (respBuffer_q_q_empty$EN)
	  respBuffer_q_q_empty <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_empty$D_IN;
	if (respBuffer_q_q_front$EN)
	  respBuffer_q_q_front <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_front$D_IN;
	if (respBuffer_q_q_full$EN)
	  respBuffer_q_q_full <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_full$D_IN;
	if (respBuffer_q_q_length$EN)
	  respBuffer_q_q_length <= `BSV_ASSIGNMENT_DELAY
	      respBuffer_q_q_length$D_IN;
	if (tokens_0$EN) tokens_0 <= `BSV_ASSIGNMENT_DELAY tokens_0$D_IN;
	if (tokens_1$EN) tokens_1 <= `BSV_ASSIGNMENT_DELAY tokens_1$D_IN;
	if (tokens_10$EN) tokens_10 <= `BSV_ASSIGNMENT_DELAY tokens_10$D_IN;
	if (tokens_11$EN) tokens_11 <= `BSV_ASSIGNMENT_DELAY tokens_11$D_IN;
	if (tokens_12$EN) tokens_12 <= `BSV_ASSIGNMENT_DELAY tokens_12$D_IN;
	if (tokens_13$EN) tokens_13 <= `BSV_ASSIGNMENT_DELAY tokens_13$D_IN;
	if (tokens_14$EN) tokens_14 <= `BSV_ASSIGNMENT_DELAY tokens_14$D_IN;
	if (tokens_15$EN) tokens_15 <= `BSV_ASSIGNMENT_DELAY tokens_15$D_IN;
	if (tokens_2$EN) tokens_2 <= `BSV_ASSIGNMENT_DELAY tokens_2$D_IN;
	if (tokens_3$EN) tokens_3 <= `BSV_ASSIGNMENT_DELAY tokens_3$D_IN;
	if (tokens_4$EN) tokens_4 <= `BSV_ASSIGNMENT_DELAY tokens_4$D_IN;
	if (tokens_5$EN) tokens_5 <= `BSV_ASSIGNMENT_DELAY tokens_5$D_IN;
	if (tokens_6$EN) tokens_6 <= `BSV_ASSIGNMENT_DELAY tokens_6$D_IN;
	if (tokens_7$EN) tokens_7 <= `BSV_ASSIGNMENT_DELAY tokens_7$D_IN;
	if (tokens_8$EN) tokens_8 <= `BSV_ASSIGNMENT_DELAY tokens_8$D_IN;
	if (tokens_9$EN) tokens_9 <= `BSV_ASSIGNMENT_DELAY tokens_9$D_IN;
      end
    if (intMult_reg1$EN)
      intMult_reg1 <= `BSV_ASSIGNMENT_DELAY intMult_reg1$D_IN;
    if (intMult_reg2$EN)
      intMult_reg2 <= `BSV_ASSIGNMENT_DELAY intMult_reg2$D_IN;
    if (intMult_reg3$EN)
      intMult_reg3 <= `BSV_ASSIGNMENT_DELAY intMult_reg3$D_IN;
    if (intMult_sel1$EN)
      intMult_sel1 <= `BSV_ASSIGNMENT_DELAY intMult_sel1$D_IN;
    if (intMult_sel2$EN)
      intMult_sel2 <= `BSV_ASSIGNMENT_DELAY intMult_sel2$D_IN;
    if (respBuffer_buffer$EN)
      respBuffer_buffer <= `BSV_ASSIGNMENT_DELAY respBuffer_buffer$D_IN;
    if (respBuffer_frontReg$EN)
      respBuffer_frontReg <= `BSV_ASSIGNMENT_DELAY respBuffer_frontReg$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    inflightCount_count = 6'h2A;
    inflightCount_full = 1'h0;
    intMult_reg1 = 66'h2AAAAAAAAAAAAAAAA;
    intMult_reg2 = 66'h2AAAAAAAAAAAAAAAA;
    intMult_reg3 = 32'hAAAAAAAA;
    intMult_sel1 = 1'h0;
    intMult_sel2 = 1'h0;
    respBuffer_buffer = 42'h2AAAAAAAAAA;
    respBuffer_bufferValid = 1'h0;
    respBuffer_frontReg = 42'h2AAAAAAAAAA;
    respBuffer_frontValid = 1'h0;
    respBuffer_qValid = 1'h0;
    respBuffer_q_q_back = 5'h0A;
    respBuffer_q_q_canPeekReg = 1'h0;
    respBuffer_q_q_deqEnable = 1'h0;
    respBuffer_q_q_empty = 1'h0;
    respBuffer_q_q_front = 5'h0A;
    respBuffer_q_q_full = 1'h0;
    respBuffer_q_q_length = 6'h2A;
    tokens_0 = 10'h2AA;
    tokens_1 = 10'h2AA;
    tokens_10 = 10'h2AA;
    tokens_11 = 10'h2AA;
    tokens_12 = 10'h2AA;
    tokens_13 = 10'h2AA;
    tokens_14 = 10'h2AA;
    tokens_15 = 10'h2AA;
    tokens_2 = 10'h2AA;
    tokens_3 = 10'h2AA;
    tokens_4 = 10'h2AA;
    tokens_5 = 10'h2AA;
    tokens_6 = 10'h2AA;
    tokens_7 = 10'h2AA;
    tokens_8 = 10'h2AA;
    tokens_9 = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFPU

